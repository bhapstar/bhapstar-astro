<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jigsaw â€” bhapstar</title>

  <!-- Cloudflare Web Analytics (optional, see note below) -->
  <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token":"b3353c7dd8764a64baee57fd09c3dbb9"}'></script><!-- End Cloudflare Web Analytics -->

  <link rel="stylesheet" href="styles.css" />

  <style>
    /* Minimal page styling that fits your site */
    .puzzle-wrap{ max-width:980px; margin:0 auto; padding:16px; }
    .puzzle-top{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:12px 14px;
      background:rgba(255,255,255,.04);
      margin:18px 0 14px;
    }
    .puzzle-top h2{ margin:0; font-size:18px; }
    .puzzle-top .sub{ font-size:12px; opacity:.8; margin-top:4px; }
    .puzzle-controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .puzzle-controls select,
    .puzzle-controls button{
      appearance:none;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.28);
      color:#fff;
      padding:10px 12px;
      font-size:14px;
      cursor:pointer;
    }
    .puzzle-board{
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background:rgba(255,255,255,.04);
      padding:12px;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:12px;
      background:#05050c;
      touch-action:none; /* IMPORTANT for finger dragging */
    }
    .puzzle-msg{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      font-size:13px;
      opacity:.9;
    }

    /* =========================================================
       WIN OVERLAY (popup message)
    ========================================================= */
    .win-overlay{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(3px);
    }
    .win-overlay.show{ display:flex; }

    .win-card{
      width: min(520px, calc(100% - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(12,12,18,.92);
      box-shadow: 0 18px 55px rgba(0,0,0,.55);
      padding: 18px;
      text-align: center;
    }
    .win-card h3{ margin: 0 0 8px 0; font-size: 18px; }
    .win-card p{
      margin: 0 0 14px 0;
      font-size: 13px;
      color: rgba(255,255,255,.78);
      line-height: 1.5;
    }
    .win-actions{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap: wrap;
    }
    .win-actions .btn{
      border-radius: 999px;
      padding: 10px 14px;
    }

    /* Prominent completion message */
    .puzzle-msg.win{
      font-size: 18px;
      font-weight: 700;
      text-align: center;
      padding: 16px 18px;
      background: linear-gradient(135deg, rgba(124,200,255,.18), rgba(255,255,255,.07));
      border: 1px solid rgba(124,200,255,.45);
      box-shadow: 0 0 26px rgba(124,200,255,.22);
      animation: pulseWin 1.6s ease-in-out infinite alternate;
    }

    @keyframes pulseWin{
      from{ transform: scale(1); }
      to{ transform: scale(1.03); }
    }
  </style>
</head>

<body>

<!-- =========================
     Header / navigation
========================= -->
<div id="siteHeader"></div>

<main class="section">
  <div class="puzzle-wrap">

    <div class="puzzle-top">
      <div>
        <h2>Random Gallery Jigsaw Puzzle</h2>
        <div class="sub">Drag the puzzle pieces into place. They snap when close. You can use Peek if youâ€™re stuck.</div>
      </div>

      <div class="puzzle-controls">
        <select id="difficulty" aria-label="Difficulty">
          <option value="3">Easy (3Ã—3)</option>
          <option value="4" selected>Normal (4Ã—4)</option>
          <option value="5">Hard (5Ã—5)</option>
        </select>
        <button id="newBtn" type="button">New random image</button>
        <button id="peekBtn" type="button" title="Hold to peek">Peek</button>
      </div>
    </div>

    <div class="puzzle-board">
      <canvas id="c"></canvas>
      <div class="puzzle-msg" id="msg">Loadingâ€¦</div>
    </div>

  </div>
</main>

<!-- =========================
     Footer
========================= -->
<div id="siteFooter"></div>

<script>
/* Burger menu controller (same as your pages) */
(function(){
  const burger = document.querySelector('.burger');
  const menu = document.querySelector('.nav-menu');
  if(!burger || !menu) return;

  burger.addEventListener('click', () => {
    const open = menu.classList.toggle('open');
    burger.setAttribute('aria-expanded', open ? 'true' : 'false');
  });

  document.addEventListener('click', (e) => {
    if(menu.classList.contains('open') && !menu.contains(e.target) && !burger.contains(e.target)){
      menu.classList.remove('open');
      burger.setAttribute('aria-expanded','false');
    }
  });

  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape'){
      menu.classList.remove('open');
      burger.setAttribute('aria-expanded','false');
    }
  });
})();
</script>

<script>
(() => {
  // ---------- Pull a random IMAGE file from your gallery-data.json (skip vimeo) ----------
  async function loadGalleryData(){
    const res = await fetch('gallery-data.json', { cache: 'no-store' });
    if(!res.ok) throw new Error('HTTP ' + res.status);
    return await res.json();
  }

  // Flatten to list of image candidates {file, title}
  function flattenImages(items){
    const out = [];
    for(const item of items){
      if(item && Array.isArray(item.videos) && item.videos.length){
        // Skip videos entirely
      }

      if(item && Array.isArray(item.images) && item.images.length){
        for(const im of item.images){
          if(im && im.file) out.push({ file: im.file, title: item.title || im.alt || "Untitled" });
        }
        continue;
      }

      if(item && item.file && typeof item.file === 'string'){
        out.push({ file: item.file, title: item.title || item.alt || "Untitled" });
      }
    }
    return out;
  }

  function pickRandom(arr){
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // ---------- Canvas jigsaw ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const msg = document.getElementById('msg');
  const difficultyEl = document.getElementById('difficulty');
  const newBtn = document.getElementById('newBtn');
  const peekBtn = document.getElementById('peekBtn');

  let img = new Image();
  img.crossOrigin = "anonymous";

  let grid = 4;
  let pieces = [];
  let board = { w: 0, h: 0 };
  let dragging = null;
  let peek = false;

  let candidates = [];

  // âœ… NEW: stores the current image title for win message
  let currentImageTitle = "";

  function setMsg(text){ msg.textContent = text; }

  // Used to cycle through overlapping pieces (tap same spot repeatedly)
  let lastPick = { x:0, y:0, t:0, idx:0, stack: null };

  /* =========================================================
     WIN OVERLAY + FIREWORKS (added)
  ========================================================= */
  const winOverlay = document.getElementById('winOverlay');
  const winNewBtn = document.getElementById('winNewBtn');
  const winCloseBtn = document.getElementById('winCloseBtn');

  // Fullscreen FX canvas for fireworks/confetti
  const fx = document.createElement('canvas');
  const fxCtx = fx.getContext('2d');
  fx.style.position = 'fixed';
  fx.style.inset = '0';
  fx.style.pointerEvents = 'none';
  fx.style.zIndex = '9998';
  fx.style.display = 'none';
  document.body.appendChild(fx);

  function resizeFx(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    fx.width = Math.floor(window.innerWidth * dpr);
    fx.height = Math.floor(window.innerHeight * dpr);
    fxCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeFx);

  function fireworksBurst(){
    resizeFx();
    fx.style.display = 'block';

    const W = window.innerWidth;
    const H = window.innerHeight;

    const bursts = 10; // more bursts
    const particles = [];

    function addBurst(cx, cy){
      const count = 110; // more particles per burst
      for(let i=0; i<count; i++){
        const a = Math.random() * Math.PI * 2;
        const sp = 2 + Math.random() * 5.5;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(a) * sp,
          vy: Math.sin(a) * sp,
          g: 0.06 + Math.random() * 0.07,
          life: 120 + Math.floor(Math.random() * 60), // much longer life
          r: 1.5 + Math.random() * 2.3,
          col: `hsl(${Math.floor(Math.random()*360)}, 90%, ${55 + Math.floor(Math.random()*20)}%)`
        });
      }
    }

    for(let b=0; b<bursts; b++){
      const cx = W * (0.2 + Math.random() * 0.6);
      const cy = H * (0.18 + Math.random() * 0.45);
      addBurst(cx, cy);
    }

    let t = 0;
    function frame(){
      t++;
      fxCtx.clearRect(0,0,W,H);

      for(let i=particles.length-1; i>=0; i--){
        const p = particles[i];
        p.life--;
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.985;
        p.vy *= 0.985;

        const alpha = Math.max(0, Math.min(1, p.life / 160));
        fxCtx.globalAlpha = alpha;
        fxCtx.fillStyle = p.col;
        fxCtx.beginPath();
        fxCtx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        fxCtx.fill();

        if(p.life <= 0) particles.splice(i,1);
      }

      fxCtx.globalAlpha = 1;

      if(particles.length && t < 320){  // ~3â€“4 seconds
        requestAnimationFrame(frame);
      }else{
        fxCtx.clearRect(0,0,W,H);
        fx.style.display = 'none';
      }
    }

    requestAnimationFrame(frame);
  }

  function showWin(){
    fireworksBurst();
    if(winOverlay){
      winOverlay.classList.add('show');
      winOverlay.setAttribute('aria-hidden','false');
    }
  }

  function hideWin(){
    if(winOverlay){
      winOverlay.classList.remove('show');
      winOverlay.setAttribute('aria-hidden','true');
    }
  }

  winNewBtn && winNewBtn.addEventListener('click', () => {
    hideWin();
    startNewGame();
  });

  winCloseBtn && winCloseBtn.addEventListener('click', hideWin);

  winOverlay && winOverlay.addEventListener('click', (e) => {
    if(e.target === winOverlay) hideWin();
  });

  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape') hideWin();
  });

  async function boot(){
    try{
      const galleryItems = await loadGalleryData();
      candidates = flattenImages(galleryItems);
      startNewGame();
    }catch(err){
      console.error(err);
      setMsg("Couldnâ€™t load gallery-data.json");
    }
  }

  boot();

  function resizeCanvasToFit(){
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.min(rect.width || 900, 980);
    const aspect = (img && img.naturalWidth) ? (img.naturalHeight / img.naturalWidth) : (2/3);
    const cssH = Math.max(320, Math.min(700, cssW * aspect));
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    board.w = cssW;
    board.h = cssH;
    draw();
  }

  /* =========================================================
     JIGSAW SHAPE SUPPORT (tabs/slots)
  ========================================================= */

  function buildEdgeMap(rows, cols){
    const edges = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => ({ top:0,right:0,bottom:0,left:0 }))
    );

    for(let r=0; r<rows; r++){
      for(let c=0; c<cols; c++){
        if(r === 0) edges[r][c].top = 0;
        if(c === 0) edges[r][c].left = 0;
        if(r === rows-1) edges[r][c].bottom = 0;
        if(c === cols-1) edges[r][c].right = 0;

        if(c < cols-1){
          const v = (Math.random() < 0.5) ? 1 : -1;
          edges[r][c].right = v;
          edges[r][c+1].left = -v;
        }
        if(r < rows-1){
          const v = (Math.random() < 0.5) ? 1 : -1;
          edges[r][c].bottom = v;
          edges[r+1][c].top = -v;
        }
      }
    }
    return edges;
  }

  function makePiecePath(w, h, e){
    const size = Math.min(w, h);
    const tab = size * 0.22;
    const neck = size * 0.14;
    const midX = w / 2;
    const midY = h / 2;

    const p = new Path2D();
    p.moveTo(0, 0);

    if(e.top === 0){
      p.lineTo(w, 0);
    }else{
      const out = (e.top === 1) ? -1 : 1;
      p.lineTo(midX - neck, 0);
      p.bezierCurveTo(midX - neck/2, 0, midX - neck/2, tab*out, midX, tab*out);
      p.bezierCurveTo(midX + neck/2, tab*out, midX + neck/2, 0, midX + neck, 0);
      p.lineTo(w, 0);
    }

    if(e.right === 0){
      p.lineTo(w, h);
    }else{
      const out = (e.right === 1) ? 1 : -1;
      p.lineTo(w, midY - neck);
      p.bezierCurveTo(w, midY - neck/2, w + tab*out, midY - neck/2, w + tab*out, midY);
      p.bezierCurveTo(w + tab*out, midY + neck/2, w, midY + neck/2, w, midY + neck);
      p.lineTo(w, h);
    }

    if(e.bottom === 0){
      p.lineTo(0, h);
    }else{
      const out = (e.bottom === 1) ? 1 : -1;
      p.lineTo(midX + neck, h);
      p.bezierCurveTo(midX + neck/2, h, midX + neck/2, h + tab*out, midX, h + tab*out);
      p.bezierCurveTo(midX - neck/2, h + tab*out, midX - neck/2, h, midX - neck, h);
      p.lineTo(0, h);
    }

    if(e.left === 0){
      p.closePath();
    }else{
      const out = (e.left === 1) ? -1 : 1;
      p.lineTo(0, midY + neck);
      p.bezierCurveTo(0, midY + neck/2, tab*out, midY + neck/2, tab*out, midY);
      p.bezierCurveTo(tab*out, midY - neck/2, 0, midY - neck/2, 0, midY - neck);
      p.closePath();
    }

    return p;
  }

  let edgeMap = null;

  function makePieces(){
    pieces = [];
    const pw = board.w / grid;
    const ph = board.h / grid;

    edgeMap = buildEdgeMap(grid, grid);

    const starts = [];
    for(let r=0; r<grid; r++){
      for(let c=0; c<grid; c++){
        starts.push({
          r, c,
          targetX: c * pw,
          targetY: r * ph,
          sx: c * (img.naturalWidth / grid),
          sy: r * (img.naturalHeight / grid),
          edges: edgeMap[r][c]
        });
      }
    }

    const shuffled = starts.map(() => ({
      x: Math.random() * (board.w - pw),
      y: Math.random() * (board.h - ph)
    }));

    for(let i=0; i<starts.length; i++){
      const s = starts[i];
      const p = shuffled[i];
      pieces.push({
        r: s.r, c: s.c,
        x: p.x, y: p.y, w: pw, h: ph,
        targetX: s.targetX, targetY: s.targetY,
        sx: s.sx, sy: s.sy, sw: img.naturalWidth/grid, sh: img.naturalHeight/grid,
        locked: false,
        edges: s.edges,
        path: makePiecePath(pw, ph, s.edges)
      });
    }
  }

  function drawPiece(p){
    ctx.save();
    ctx.translate(p.x, p.y);

    ctx.save();
    ctx.clip(p.path);

    ctx.drawImage(
      img,
      0, 0, img.naturalWidth, img.naturalHeight,
      -p.targetX, -p.targetY, board.w, board.h
    );

    ctx.globalAlpha = 0.06;
    ctx.fillStyle = "#fff";
    ctx.fill(p.path);
    ctx.globalAlpha = 1;

    ctx.restore();

    ctx.lineWidth = 1;
    ctx.strokeStyle = p.locked ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.40)";
    ctx.stroke(p.path);

    if(!p.locked){
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,.45)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 10;
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.stroke(p.path);
      ctx.restore();
    }

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,board.w,board.h);

    if(!img || !img.naturalWidth){
      ctx.fillStyle = "rgba(255,255,255,.7)";
      ctx.font = "14px system-ui";
      ctx.fillText("No image loaded.", 16, 28);
      return;
    }

    if(peek){
      ctx.globalAlpha = 0.25;
      ctx.drawImage(img, 0,0,img.naturalWidth,img.naturalHeight, 0,0,board.w,board.h);
      ctx.globalAlpha = 1;
    }

    const ordered = [...pieces].sort((a,b)=> (a.locked - b.locked));
    for(const p of ordered){
      drawPiece(p);
    }
  }

  // Return ALL unlocked pieces under the pointer, top-to-bottom
  function hitStack(x,y){
    const hits = [];
    for(let i=pieces.length-1; i>=0; i--){
      const p = pieces[i];
      if(p.locked) continue;

      const lx = x - p.x;
      const ly = y - p.y;

      if(lx < 0 || ly < 0 || lx > p.w || ly > p.h) continue;
      if(ctx.isPointInPath(p.path, lx, ly)) hits.push(p);
    }
    return hits; // [topmost, ..., bottommost]
  }

  function bringToFront(piece){
    const idx = pieces.indexOf(piece);
    if(idx >= 0){ pieces.splice(idx,1); pieces.push(piece); }
  }

  function maybeSnap(p){
    const dx = p.x - p.targetX;
    const dy = p.y - p.targetY;
    const dist = Math.hypot(dx,dy);
    const thresh = Math.min(p.w,p.h) * 0.18;
    if(dist < thresh){
      p.x = p.targetX; p.y = p.targetY; p.locked = true;
      return true;
    }
    return false;
  }

  function checkWin(){ return pieces.every(p=>p.locked); }

  function pointerPos(ev){
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (board.w / rect.width);
    const y = (ev.clientY - rect.top) * (board.h / rect.height);
    return {x,y};
  }

  canvas.addEventListener('pointerdown', (ev) => {
    canvas.setPointerCapture(ev.pointerId);
    const {x,y} = pointerPos(ev);

    const stack = hitStack(x,y);
    if(!stack.length) return;

    const now = performance.now();
    const close = Math.hypot(x - lastPick.x, y - lastPick.y) < 10;
    const quick = (now - lastPick.t) < 700;

    // If user taps same spot quickly, cycle to the next piece underneath
    if(close && quick && lastPick.stack && lastPick.stack.length){
      const sameSet =
        lastPick.stack.length === stack.length &&
        lastPick.stack.every((p, i) => p === stack[i]);

      lastPick.idx = sameSet ? (lastPick.idx + 1) % stack.length : 0;
    }else{
      lastPick.idx = 0;
    }

    lastPick.x = x;
    lastPick.y = y;
    lastPick.t = now;
    lastPick.stack = stack;

    const p = stack[lastPick.idx];
    bringToFront(p);
    dragging = { piece:p, dx:x-p.x, dy:y-p.y };
    draw();
  });

  canvas.addEventListener('pointermove', (ev) => {
    if(!dragging) return;
    const {x,y} = pointerPos(ev);
    const p = dragging.piece;

    p.x = x - dragging.dx;
    p.y = y - dragging.dy;
    p.x = Math.max(0, Math.min(board.w - p.w, p.x));
    p.y = Math.max(0, Math.min(board.h - p.h, p.y));
    draw();
  });

  function endDrag(){
    if(!dragging) return;
    const p = dragging.piece;
    dragging = null;

    const snapped = maybeSnap(p);
    draw();

    if(snapped && checkWin()){
      msg.classList.add('win');

      // âœ… UPDATED WIN MESSAGE (includes current image title)
      setMsg(`${currentImageTitle} reconstructed. Nicely done ðŸŒŒ Tap â€œNew random imageâ€ to explore another fragment of the universe. ðŸ”­`);

      showWin();
    }
  }

  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);

  const startPeek = () => { peek = true; draw(); };
  const stopPeek  = () => { peek = false; draw(); };
  peekBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); startPeek(); });
  peekBtn.addEventListener('pointerup', stopPeek);
  peekBtn.addEventListener('pointerleave', stopPeek);
  peekBtn.addEventListener('pointercancel', stopPeek);

  function startNewGame(){
    msg.classList.remove('win');
    grid = parseInt(difficultyEl.value, 10) || 4;

    if(!candidates.length){
      setMsg("No images found in galleryData.");
      return;
    }

    const pick = pickRandom(candidates);

    // âœ… NEW: remember title for win message
    currentImageTitle = pick.title || "Untitled";

    setMsg(`Loading: ${pick.title}`);

    img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      resizeCanvasToFit();
      makePieces();
      draw();
      setMsg("Drag pieces into place. They snap when close.");
    };
    img.onerror = () => setMsg("Couldnâ€™t load that image file.");
    img.src = pick.file;
  }

  newBtn.addEventListener('click', startNewGame);
  difficultyEl.addEventListener('change', startNewGame);

  window.addEventListener('resize', () => {
    if(!img || !img.naturalWidth) return;
    startNewGame();
  });

})();
</script>

<!-- Win overlay (added) -->
<div class="win-overlay" id="winOverlay" aria-hidden="true">
  <div class="win-card" role="dialog" aria-modal="true" aria-label="Puzzle completed">
    <h3>Yay! Completed ðŸŽ‰</h3>
    <p>Well done. Now try another random image.</p>
    <div class="win-actions">
      <button class="btn primary" type="button" id="winNewBtn">New random image</button>
      <button class="btn" type="button" id="winCloseBtn">Close</button>
    </div>
  </div>
</div>

<script src="protect-images.js"></script>
<script src="partials/partials.js"></script>

</body>
</html>
